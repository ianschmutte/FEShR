##' @title URE
##' @description Calculates URE(mu, Lambda) as defined in Kwon (2020)
##' 
##' @param mu 
##' @param Lambda 
##' @param y a T-by-J data matrix
##' @param M a length J list with the corresponding covariance matrices 
##' @param T 
URE <- function(mu, Lambda, y, M) {

  if (!is.matrix(y)) {
    stop("y must be a matrix")
  }

  T <- nrow(y)
  J <- ncol(y)
 
  URE <- 0
  for (j in 1:J) {
    y_j <- y[, j]
    M_j <- M[[j]]
    URE <- URE + URE_j(mu, Lambda, y_j, M_j)
  }
  return(URE)
}


##' @title URE with covariates
##' @description Calculates URE(Z\gamma, Lambda) as defined in Kwon (2020)
##' 
##' @param gamma 
##' @param Lambda 
##' @param y a T-by-J data matrix
##' @param M a length J list with the corresponding covariance matrices 
##' @param Z a length J list with the corresponding T-by-k covariate matrices
URE_cov <- function(gamma, Lambda, y, M, Z) {

  if (!is.matrix(y)) {
    stop("y must be a matrix")
  }

  T <- nrow(y)
  J <- ncol(y)
 
  URE <- 0
  for (j in 1:J) {
    y_j <- y[, j]
    M_j <- M[[j]]
    URE <- URE + URE_j(Z[[j]] %*% gamma, Lambda, y_j, M_j)
  }
  return(URE)
}

##' @title make_URE_j
##' @description Makes the function that calculate the component of URE(mu,
##'   Lambda) that cooresponds to the jth observation ..
##' @param y_j
##' @param M_j
URE_j <- function(mu, Lambda, y_j, M_j) {

  inv_Lam_Mj <- solve(Lambda + M_j)
  URE_j <- -2 * sum(diag(inv_Lam_Mj %*% M_j %*% M_j))
  URE_j <- URE_j + sum((M_j %*% inv_Lam_Mj %*% (y_j - mu))^2)

  return(URE_j)
}


##' @title URE_diag
##' @description Calculates URE(mu, Lambda) as defined in Xie, Kou, and Brown
##'   (2012), but allowed to have different lambdas periodwise
##' 
##' @param mu location vector to be tuned
##' @param Lambda a T vector to be tuned
##' @param y a TJ vector of the observations, which is constructed by
##'   concatenating the y_j's (as opposed to concatenating the y_t's)
##' @param M
URE_diag <- function(mu, Lambda, y, M) {
  inv_Lam_M <- 1 / (Lambda + M)
  URE <- -2 * sum(inv_Lam_M * M^2) + sum(M * inv_Lam_M * (y - mu)^2)
  return(URE)
}



make_from_lowertri <- function(L, T) {
  L_mat <- matrix(0, nrow = T, ncol = T)
  L_mat[lower.tri(L_mat, diag = TRUE)] <- L
  return(L_mat %*% t(L_mat))
}

################################################################################
#################################### DGP #######################################
################################################################################


J <- 100
T <- 4
M <- vector(mode = "list", length = J)
## theta <- matrix(2 * runif(T * J), nrow = T)
## theta <- matrix(rbind(runif((T / 2) * J), 2 * runif((T / 2) * J)), nrow = T)
theta1 <- matrix(rbind(runif(J),
                      .5 * runif(J),
                      1.5 * runif(J),
                      2 * runif(J)),
                nrow = T)

theta2 < matrix(rbind(2 * rnorm(J),
                      .5 * runif(J),
                      1.5 * runif(J),
                      4 * runif(J)),
                nrow = T)

theta <- 

## theta_Js <- 2 * rnorm(J)
## theta_Ts <- rnorm(T)
## theta <- matrix(rep(theta_Js, T), nrow = J)
## theta <- t(theta) + matrix(rep(theta_Ts, J), nrow = T)

for (j in 1:J) {
  L <- matrix(runif(T^2), nrow = T)
  M[[j]] <- t(L) %*% L
  ## M[[j]] <- diag(c(runif(1), runif(1) + .5, 2 * runif(1), runif(1) + 2))
}



################################################################################
############################### Simulations ####################################
################################################################################

Nrep <- 10

thetahat_SURE_list <- vector(mode = "list", length = Nrep)
Lambdas_SURE <- vector(mode = "list", length = Nrep)

thetahat_SURE_list_or <- vector(mode = "list", length = Nrep)
Lambdas_SURE_or <- vector(mode = "list", length = Nrep)

thetahat_SURE_list_XKB <- vector(mode = "list", length = Nrep)
Lambdas_SURE_XKB <- vector(mode = "list", length = Nrep)

thetahat_SURE_list_XKB_or <- vector(mode = "list", length = Nrep)
Lambdas_SURE_XKB_or <- vector(mode = "list", length = Nrep)

ys <- vector(mode = "list", length = Nrep)

for(rep in 1:Nrep) {
  print(rep)

  y <- matrix(NA, nrow = T, ncol = J)

  for(j in 1:J) {
    y[, j] <- mvtnorm::rmvnorm(n = 1, mean = rep(0, T), sigma = M[[j]]) +
      theta[, j]
  }
  ys[[rep]] <- y
  
  L <- optim(par = rep(0, T*(T+1)/2), obj_SURE, y = y, M = M, T = T)$par
  L_or <- optim(par = rep(0, T*(T+1)/2), oracle_SURE, y = y, M = M, T = T,
                theta = theta)$par
  Lambda_SURE_XKB <- optimize(SURE, c(0, 1e05),
                              y = y, M = M, T = T, XKB = TRUE)$min
  Lambda_SURE_XKB_or <- optimize(oracle_SURE, c(0,1e05),
                                 y = y, M = M, T = T, theta = theta)$min
  
  Lambdas_SURE[[rep]] <- Lambda_SURE <- make_from_lowertri(L, T)
  Lambdas_SURE_or[[rep]] <- Lambda_SURE_or <- make_from_lowertri(L_or, T)
  Lambdas_SURE_XKB[[rep]] <- Lambda_SURE_XKB
  Lambdas_SURE_XKB_or[[rep]] <- Lambda_SURE_XKB_or
  
  thetahat_SURE <- matrix(NA, ncol = J, nrow = T)
  thetahat_SURE_or <- matrix(NA, ncol = J, nrow = T)
  thetahat_SURE_XKB <- matrix(NA, ncol = J, nrow = T)
  thetahat_SURE_XKB_or <- matrix(NA, ncol = J, nrow = T)
  
  for(j in 1:J) {
    thetahat_SURE[, j] <- thetahat_Lambda(Lambda_SURE, M[[j]], y[, j])
    thetahat_SURE_or[, j] <- thetahat_Lambda(Lambda_SURE_or, M[[j]], y[, j])
    thetahat_SURE_XKB[, j] <- thetahat_Lambda(Lambda_SURE_XKB, M[[j]], y[, j])
    thetahat_SURE_XKB_or[, j] <- thetahat_Lambda(Lambda_SURE_XKB_or,
                                                 M[[j]], y[, j])
  }
  
  thetahat_SURE_list[[rep]] <- thetahat_SURE
  thetahat_SURE_list_or[[rep]] <- thetahat_SURE_or
  thetahat_SURE_list_XKB[[rep]] <- thetahat_SURE_XKB
  thetahat_SURE_list_XKB_or[[rep]] <- thetahat_SURE_XKB_or
}


SURE_MSE <- average_MSE(theta, thetahat_SURE_list)
SURE_MSE_XKB <- average_MSE(theta, thetahat_SURE_list_XKB)
SURE_MSE_oracle <- average_MSE(theta, thetahat_SURE_list_or)
SURE_MSE_XKB_or <- average_MSE(theta, thetahat_SURE_list_XKB_or)
MLE_MSE <- average_MSE(theta, ys)
MLE_MSE_true <- mean(sapply(1:J, function(j) sum(diag(M[[j]]))))

MSEs <- c(SURE_MSE, SURE_MSE_XKB, SURE_MSE_oracle, SURE_MSE_XKB_or,
          MLE_MSE, MLE_MSE_true)
names(MSEs) <- c("SURE", "SURE XKB", "SURE Oracle", "SURE XKB Oracle",
                 "MLE", "True MLE")

print(MSEs)

### Thinks to try ###
### 1. period-by-period XKB
### 2. homoskedasticity
### 3. prediction

